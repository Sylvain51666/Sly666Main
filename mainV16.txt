/**
 * @file main.cpp
 * @author Sly
 * @brief Dashboard domotique pour M5Stack Core2 avec calcul astronomique, modes jour/nuit et toast feedback
 * @version 16 - Calcul astronomique corrigé + debug mode
 * @date 2025-08-25
 */

#include <M5Unified.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <PubSubClient.h>
#include <SD.h>
#include <SPI.h>
#include <vector>
#include <cmath>
#include "time.h"
#include "pac_fan_assets.h" // fan_frame1_png / fan_frame2_png

// ============================== RÉSEAU ==============================
const char* WIFI_SSID = "Sly";
const char* WIFI_PASS = "SlyIsTheBest!@";

// MQTT: conservé uniquement pour piscine/eau/heure/pompe
const char* MQTT_BROKER = "192.168.1.189";
const char* MQTT_CLIENT_ID = "m5stack-core2-visual";
const char* MQTT_USER = "Sly";
const char* MQTT_PASS = "BIGjim2133";
const int   MQTT_KEEPALIVE_SECONDS = 60;

const char* TOPIC_PISCINE = "homie/homey/m5core2/devicecapabilities-texttext1";
const char* TOPIC_EAU     = "homie/homey/m5core2/devicecapabilities-texttext2";
const char* TOPIC_HEURE   = "homie/homey/m5core2/devicecapabilities-texttext4";
const char* TOPIC_POMPE_PISCINE = "homie/homey/pompe-de-la-piscine/onoff";

// NTP
const char* NTP_SERVER = "pool.ntp.org";
const long  GMT_OFFSET_SEC = 3600;
const int   DAYLIGHT_OFFSET_SEC = 3600;

// Shelly HTTP RPC
const char* SHELLY_HOST = "192.168.1.33";
const uint32_t SHELLY_POLL_MS = 1000;

// ====== Position géographique pour calcul astronomique ======
const double LATITUDE = 49.212665313471724;
const double LONGITUDE = 4.0364085300482575;

// ====== Déclarations globales MQTT ======
WiFiClient wifiClient;
PubSubClient mqttClient(wifiClient);

// ===================== WATCHDOG & TIMEOUT ======================
unsigned long lastDataReceived = 0;
unsigned long lastMqttReconnectAttempt = 0;
unsigned long lastWifiReconnectAttempt = 0;
unsigned long lastDisplayUpdate = 0;
unsigned long lastBrightnessCheck = 0;
unsigned long lastLogCleanup = 0;
unsigned long bootTime = 0;

const unsigned long DATA_TIMEOUT = 300000;
const unsigned long MQTT_RECONNECT_INTERVAL = 5000;
const unsigned long WIFI_RECONNECT_INTERVAL  = 10000;
const unsigned long BRIGHTNESS_CHECK_INTERVAL = 10000;
const unsigned long LOG_CLEANUP_INTERVAL = 3600000;

int mqttReconnectAttempts = 0;
int wifiReconnectAttempts = 0;
const int MAX_RECONNECT_ATTEMPTS = 10;

// ===================== CALCUL ASTRONOMIQUE ======================
struct SolarTimes {
  int sunriseHour = 7;
  int sunriseMinute = 0;
  int sunsetHour = 19;
  int sunsetMinute = 0;
  int dayOfYear = 0;
  bool isValid = false;
};
SolarTimes solarTimes;
unsigned long lastSolarCalculation = 0;

// ===================== MODES JOUR/NUIT ======================
enum DisplayMode { MODE_AUTO = 0, MODE_FORCE_DAY = 1, MODE_FORCE_NIGHT = 2 };
DisplayMode currentDisplayMode = MODE_AUTO;
bool isNightMode = false;
bool backgroundImageChanged = false;
unsigned long lastModeSwitch = 0;
const unsigned long MODE_SWITCH_COOLDOWN = 1000;

// ===================== DOUBLE TAP DETECTION ======================
struct TouchState {
  bool isTouched = false;
  unsigned long firstTapTime = 0;
  unsigned long lastTapTime = 0;
  int tapCount = 0;
  bool doubleTapDetected = false;
};
TouchState touchState;
const unsigned long DOUBLE_TAP_TIMEOUT = 500;

// Hitbox élargie en haut à droite
const int HOUR_TOUCH_X = 220;
const int HOUR_TOUCH_Y = 0;
const int HOUR_TOUCH_W = 100;
const int HOUR_TOUCH_H = 40;

// Hitbox pour debug mode en haut à gauche
const int DEBUG_TOUCH_X = 0;
const int DEBUG_TOUCH_Y = 0;
const int DEBUG_TOUCH_W = 80;
const int DEBUG_TOUCH_H = 40;

// ===================== DEBUG MODE ======================
bool debugMode = false;
int debugScrollOffset = 0;
unsigned long lastDebugScroll = 0;
const unsigned long DEBUG_SCROLL_DELAY = 50;
String debugMessages = "";

// ===================== LOGGING SYSTÈME ======================
const char* LOG_FILE = "/system.log";
const unsigned long MAX_LOG_SIZE = 100 * 1024 * 1024;
File logFile;
enum LogLevel { LOG_INFO, LOG_WARNING, LOG_ERROR, LOG_DEBUG };

// --------- Helpers trig ----------
static constexpr double PI_C = 3.14159265358979323846;
double degToRad(double degrees) { return degrees * PI_C / 180.0; }
double radToDeg(double radians) { return radians * 180.0 / PI_C; }

// ==================== PROTOTYPES ====================
void writeLog(LogLevel level, const String& message);
void cleanupLogs();
int  getDayOfYear(int year, int month, int day);
void calculateSolarTimes();
bool isDaytimeByAstronomy();
bool shouldBeNightMode();
float getBrightnessTransitionFactor();
void updateBrightness();
void applyModeChangeNow();   // bascule immédiate + toast
static String findBgPath(bool nightMode);
static bool readFileToBuffer(const String& path, std::vector<uint8_t>& out);
bool drawBackgroundFromSD(bool nightMode);
void readAllBackgroundBuffers();
void handleTouch();
void checkSystemHealth();
void updateTimeFromRTC();
void updateAllDisplays();
void updateSolarFill();
void updatePacAnimation();
void updatePoolWaves();
void updateGridArrow();
void mqttCallback(char* topic, byte* payload, unsigned int length);
void connectWifi();
void connectMqtt();
void cleanupBuffers();
void shellyTask(void* arg);
bool isSummerTime();
void debugLogSystemStatus();
void toggleDebugMode();
void updateDebugDisplay();
void cleanupPNGBuffers();

// ==== Toast (feedback) ====
void showModeToast(const char* text);
void maybeUpdateToast();
void hideToast();

// ==================== LOGGING ====================
void writeLog(LogLevel level, const String& message) {
  const char* levelStr[] = {"INFO", "WARN", "ERROR", "DEBUG"};
  struct tm timeinfo;
  char timeStr[20] = "00:00:00";
  if (getLocalTime(&timeinfo)) sprintf(timeStr, "%02d:%02d:%02d", timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);
  String logEntry = String(timeStr) + " [" + levelStr[level] + "] " + message + "\n";
  Serial.print(logEntry);
  
  // Ajouter au debug messages
  if (debugMode && level <= LOG_DEBUG) {
    debugMessages += logEntry;
    if (debugMessages.length() > 1000) {
      debugMessages = debugMessages.substring(debugMessages.length() - 1000);
    }
  }
  
  logFile = SD.open(LOG_FILE, FILE_APPEND);
  if (logFile) { logFile.print(logEntry); logFile.close(); }
}

void cleanupLogs() {
  if (SD.exists(LOG_FILE)) {
    File f = SD.open(LOG_FILE, FILE_READ);
    if (f && f.size() > MAX_LOG_SIZE) { f.close(); SD.remove(LOG_FILE); writeLog(LOG_INFO, "Log file cleaned - size exceeded 100MB"); }
    else if (f) { f.close(); }
  }
}

// ==================== CALCUL ASTRONOMIQUE ====================
int getDayOfYear(int year, int month, int day) {
  int daysInMonth[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
  if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) daysInMonth[1] = 29;
  int doy = day;
  for (int i = 0; i < month - 1; i++) doy += daysInMonth[i];
  return doy;
}

bool isSummerTime() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) return false;
  // Logique simplifiée - dernier dimanche mars au dernier dimanche octobre
  int month = timeinfo.tm_mon + 1;
  if (month > 3 && month < 10) return true;
  if (month == 3 && timeinfo.tm_mday > 24) return true;
  if (month == 10 && timeinfo.tm_mday < 25) return true;
  return false;
}

void calculateSolarTimes() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) { 
    writeLog(LOG_ERROR, "Cannot get time for solar calculation"); 
    return; 
  }
  
  int year = timeinfo.tm_year + 1900;
  int month = timeinfo.tm_mon + 1;
  int day = timeinfo.tm_mday;
  int dayOfYear = getDayOfYear(year, month, day);
  
  if (solarTimes.isValid && solarTimes.dayOfYear == dayOfYear) return;

  writeLog(LOG_INFO, "Calculating solar times for day " + String(dayOfYear) + " of " + String(year));
  
  // Conversion des coordonnées en radians
  double latRad = degToRad(LATITUDE);
  double longHours = LONGITUDE / 15.0;
  
  // Calcul approximatif du temps solaire
  double approxTime = dayOfYear + (6.0 - longHours) / 24.0;
  
  // Calcul de l'anomalie moyenne
  double meanAnomaly = degToRad(0.9856 * approxTime - 3.289);
  
  // Calcul de la longitude écliptique
  double eclipticLon = meanAnomaly + degToRad(1.916 * sin(meanAnomaly) + 0.020 * sin(2 * meanAnomaly) + 282.634);
  if (eclipticLon > 2 * PI_C) eclipticLon -= 2 * PI_C;
  if (eclipticLon < 0) eclipticLon += 2 * PI_C;
  
  // Calcul de l'ascension droite
  double ascension = atan2(0.91764 * tan(eclipticLon), 1.0);
  if (ascension > 2 * PI_C) ascension -= 2 * PI_C;
  if (ascension < 0) ascension += 2 * PI_C;
  
  // Ajustement de l'ascension droite
  double lQuadrant = floor(eclipticLon / (PI_C / 2)) * (PI_C / 2);
  double raQuadrant = floor(ascension / (PI_C / 2)) * (PI_C / 2);
  ascension = ascension + (lQuadrant - raQuadrant);
  
  // Conversion en heures
  ascension = ascension / (PI_C / 12.0);
  
  // Calcul de la déclinaison
  double sinDec = 0.39782 * sin(eclipticLon);
  double cosDec = cos(asin(sinDec));
  
  // Calcul de l'angle horaire du soleil
  double cosZenith = cos(degToRad(90.833)); // Zenith officiel (90°50')
  double cosH = (cosZenith - (sinDec * sin(latRad))) / (cosDec * cos(latRad));
  
  if (cosH > 1 || cosH < -1) {
    writeLog(LOG_WARNING, "Sun never rises or sets at this location today");
    solarTimes.sunriseHour = 6;
    solarTimes.sunriseMinute = 0;
    solarTimes.sunsetHour = 18;
    solarTimes.sunsetMinute = 0;
    solarTimes.dayOfYear = dayOfYear;
    solarTimes.isValid = true;
    return;
  }
  
  double H = acos(cosH) * 180.0 / PI_C / 15.0;
  
  // Calcul du temps solaire
  double T = H + ascension - (0.06571 * approxTime) - 6.622;
  
  // Conversion en UTC
  double UT = T - longHours;
  if (UT < 0) UT += 24;
  if (UT >= 24) UT -= 24;
  
  // Ajustement pour le fuseau horaire (UTC+1 pour la France)
  double localT = UT + (isSummerTime() ? 2.0 : 1.0);
  
  // Calcul du lever et coucher
  double sunriseTime = localT - H;
  double sunsetTime = localT + H;
  
  // Normalisation des heures
  if (sunriseTime < 0) sunriseTime += 24;
  if (sunriseTime >= 24) sunriseTime -= 24;
  if (sunsetTime < 0) sunsetTime += 24;
  if (sunsetTime >= 24) sunsetTime -= 24;
  
  solarTimes.sunriseHour = (int)sunriseTime;
  solarTimes.sunriseMinute = (int)((sunriseTime - solarTimes.sunriseHour) * 60);
  solarTimes.sunsetHour = (int)sunsetTime;
  solarTimes.sunsetMinute = (int)((sunsetTime - solarTimes.sunsetHour) * 60);
  solarTimes.dayOfYear = dayOfYear;
  solarTimes.isValid = true;

  writeLog(LOG_INFO, "Solar times calculated - Sunrise: " + String(solarTimes.sunriseHour) + ":" +
                     String(solarTimes.sunriseMinute) + ", Sunset: " + String(solarTimes.sunsetHour) + ":" +
                     String(solarTimes.sunsetMinute));
}

// ==================== GESTION MODES JOUR/NUIT ====================
bool isDaytimeByAstronomy() {
  if (!solarTimes.isValid) return true;
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) return true;
  int currentMinutes = timeinfo.tm_hour * 60 + timeinfo.tm_min;
  int sunriseMinutes = solarTimes.sunriseHour * 60 + solarTimes.sunriseMinute + 30;
  int sunsetMinutes  = solarTimes.sunsetHour  * 60 + solarTimes.sunsetMinute;
  return (currentMinutes >= sunriseMinutes && currentMinutes < sunsetMinutes);
}
bool shouldBeNightMode() {
  switch (currentDisplayMode) {
    case MODE_FORCE_DAY:   return false;
    case MODE_FORCE_NIGHT: return true;
    case MODE_AUTO:
    default:               return !isDaytimeByAstronomy();
  }
}
float getBrightnessTransitionFactor() {
  if (!solarTimes.isValid) return 1.0;
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) return 1.0;
  int currentMinutes = timeinfo.tm_hour * 60 + timeinfo.tm_min;
  int sunriseMinutes = solarTimes.sunriseHour * 60 + solarTimes.sunriseMinute;
  int sunsetMinutes  = solarTimes.sunsetHour  * 60 + solarTimes.sunsetMinute;
  if (currentMinutes >= sunriseMinutes && currentMinutes <= sunriseMinutes + 30) {
    float progress = (currentMinutes - sunriseMinutes) / 30.0f;
    return 0.3f + (0.7f * progress);
  }
  if (currentMinutes >= sunsetMinutes && currentMinutes <= sunsetMinutes + 30) {
    float progress = (currentMinutes - sunsetMinutes) / 30.0f;
    return 1.0f - (0.7f * progress);
  }
  if (currentMinutes > sunriseMinutes + 30 && currentMinutes < sunsetMinutes) return 1.0f;
  return 0.3f;
}

// ==================== GESTION LUMINOSITÉ ====================
int currentBrightness = 200;
bool brightnessAutoMode = true;

void updateBrightness() {
  if (!brightnessAutoMode) return;
  float factor = getBrightnessTransitionFactor();
  int targetBrightness = (int)(255 * factor);
  if (currentDisplayMode == MODE_FORCE_NIGHT) targetBrightness = (int)(255 * 0.3);
  if (currentDisplayMode == MODE_FORCE_DAY)   targetBrightness = 255;
  if (abs(targetBrightness - currentBrightness) > 2) {
    currentBrightness = targetBrightness;
    M5.Display.setBrightness(currentBrightness);
    writeLog(LOG_DEBUG, "Brightness adjusted to " + String(currentBrightness) + " (" + String((currentBrightness * 100) / 255) + "%)");
  }
}

// ==================== APPLY MODE CHANGE NOW (+ toast) ====================
const int TOAST_X = 8, TOAST_Y = 8, TOAST_W = 84, TOAST_H = 28;
uint16_t* bg_buffer_toast = nullptr;
bool toastVisible = false;
unsigned long toastUntil = 0;
String toastText = "";

void hideToast() {
  if (!toastVisible) return;
  if (bg_buffer_toast) {
    M5.Display.pushImage(TOAST_X, TOAST_Y, TOAST_W, TOAST_H, bg_buffer_toast);
  }
  toastVisible = false;
}

void showModeToast(const char* text) {
  // Sauvegarde fond
  if (bg_buffer_toast == nullptr) bg_buffer_toast = (uint16_t*)malloc(TOAST_W * TOAST_H * sizeof(uint16_t));
  if (bg_buffer_toast) {
    M5.Display.readRect(TOAST_X, TOAST_Y, TOAST_W, TOAST_H, bg_buffer_toast);
  }
  // Boîte
  uint16_t bg = M5.Display.color565(20, 20, 20);
  uint16_t frame = M5.Display.color565(200, 200, 200);
  M5.Display.fillRoundRect(TOAST_X, TOAST_Y, TOAST_W, TOAST_H, 6, bg);
  M5.Display.drawRoundRect(TOAST_X, TOAST_Y, TOAST_W, TOAST_H, 6, frame);
  // Texte
  M5.Display.setTextColor(TFT_WHITE);
  M5.Display.setTextFont(2);
  M5.Display.setTextDatum(textdatum_t::middle_center);
  M5.Display.drawString(text, TOAST_X + TOAST_W/2, TOAST_Y + TOAST_H/2);
  // État
  toastText = text;
  toastVisible = true;
  toastUntil = millis() + 1000; // 1s
}

void maybeUpdateToast() {
  if (toastVisible && (long)(millis() - toastUntil) >= 0) {
    hideToast();
  }
}

void applyModeChangeNow() {
  // 1) luminosité
  updateBrightness();

  // 2) fond
  bool targetNight = shouldBeNightMode();
  isNightMode = targetNight;
  backgroundImageChanged = false;

  if (!drawBackgroundFromSD(isNightMode)) {
    writeLog(LOG_ERROR, "Failed to load background after mode change, using fallback");
    drawBackgroundFromSD(false);
  }

  // 3) relire les buffers et redraw
  readAllBackgroundBuffers();
  extern unsigned long lastForceRedraw; // défini plus bas
  lastForceRedraw = 0;
  updateAllDisplays();

  // 4) toast
  switch (currentDisplayMode) {
    case MODE_FORCE_NIGHT: showModeToast("NIGHT"); break;
    case MODE_FORCE_DAY:   showModeToast("DAY");   break;
    case MODE_AUTO:        showModeToast("AUTO");  break;
  }
}

// ==================== GESTION BACKGROUND ====================
static String findBgPath(bool nightMode) {
  if (nightMode) {
    const char* NIGHT_CANDIDATES[] = {"/bg_night.jpg", "/bg_night.jpeg", "/bg_night.png", "/bg_night.bmp"};
    for (auto c : NIGHT_CANDIDATES) { if (SD.exists(c)) return String(c); }
  }
  const char* DAY_CANDIDATES[] = {"/bg.jpg", "/bg.jpeg", "/bg.png", "/bg.bmp"};
  for (auto c : DAY_CANDIDATES) { if (SD.exists(c)) return String(c); }
  return "";
}
static bool readFileToBuffer(const String& path, std::vector<uint8_t>& out) {
  File f = SD.open(path, FILE_READ);
  if (!f) return false;
  size_t len = f.size();
  if (len == 0) { f.close(); return false; }
  out.resize(len);
  f.read(out.data(), len);
  f.close();
  return true;
}
bool drawBackgroundFromSD(bool nightMode = false) {
  String p = findBgPath(nightMode);
  if (p == "") { writeLog(LOG_ERROR, "Background image not found for " + String(nightMode ? "night" : "day") + " mode"); return false; }
  std::vector<uint8_t> buf;
  if (!readFileToBuffer(p, buf)) return false;
  M5.Display.drawJpg(buf.data(), buf.size());
  writeLog(LOG_INFO, "Background loaded: " + p);
  return true;
}

// ============================= AFFICHAGE ============================
// --- Polices ---
#define FONT_MAISON  7
#define FONT_EAU     4
#define FONT_GRID    4
#define FONT_PISCINE 4
#define FONT_PAC     2
#define FONT_PV      4
#define FONT_HEURE   2

// --- Coordonnées (écran 320x240) ---
#define HEURE_DISP_X   290
#define HEURE_DISP_Y   10
#define HEURE_DISP_W   60
#define HEURE_DISP_H   20
#define HEURE_DISP_FONT  FONT_HEURE

#define MAISON_DISP_X  160
#define MAISON_DISP_Y  30
#define MAISON_DISP_W  150
#define MAISON_DISP_H  60
#define MAISON_DISP_FONT FONT_MAISON

#define PV_DISP_X      60
#define PV_DISP_Y      45
#define PV_DISP_W      100
#define PV_DISP_H      40
#define PV_DISP_FONT   FONT_PV

#define GRID_DISP_X    180
#define GRID_DISP_Y    128
#define GRID_DISP_W    100
#define GRID_DISP_H    40
#define GRID_DISP_FONT FONT_GRID

#define EAU_DISP_X     270
#define EAU_DISP_Y     85
#define EAU_DISP_W     100
#define EAU_DISP_H     40
#define EAU_DISP_FONT  FONT_EAU

#define PISCINE_DISP_W  120
#define PISCINE_DISP_H  35
#define PISCINE_DISP_Y  222
#define PISCINE_DISP_MARGIN_LEFT 0
#define PISCINE_DISP_X  (PISCINE_DISP_MARGIN_LEFT + (PISCINE_DISP_W/2))
#define PISCINE_DISP_FONT FONT_PISCINE

#define PAC_FAN_X 234
#define PAC_FAN_Y 198
#define PAC_FAN_W 38
#define PAC_FAN_H 37

#define PAC_DISP_X     253
#define PAC_DISP_Y     186
#define PAC_DISP_W     32
#define PAC_DISP_H     20
#define PAC_DISP_FONT  FONT_PAC

#define WAVE_W 138
#define WAVE_H 27
int WAVE_X = 82;
int WAVE_Y = 213;

#define GRID_ARROW_W 36
#define GRID_ARROW_H 36
int GRID_ARROW_X = 123;
int GRID_ARROW_Y = 113;

// --- Buffers et Sprites ---
uint16_t* bg_buffer_heure;
uint16_t* bg_buffer_maison;
uint16_t* bg_buffer_pv;
uint16_t* bg_buffer_grid;
uint16_t* bg_buffer_eau;
uint16_t* bg_buffer_piscine;
uint16_t* bg_buffer_pac;
uint16_t* bg_buffer_wave;
uint16_t* bg_buffer_solar;
uint16_t* bg_buffer_fan;
uint16_t* bg_buffer_grid_arrow;

LGFX_Sprite spHeure(&M5.Display);
LGFX_Sprite spMaison(&M5.Display);
LGFX_Sprite spPV(&M5.Display);
LGFX_Sprite spGrid(&M5.Display);
LGFX_Sprite spEau(&M5.Display);
LGFX_Sprite spPiscine(&M5.Display);
LGFX_Sprite spPAC(&M5.Display);
LGFX_Sprite spSolar(&M5.Display);
LGFX_Sprite spFan(&M5.Display);
LGFX_Sprite spWave(&M5.Display);
LGFX_Sprite spGridArrow(&M5.Display);

String val_heure         = "--:--";
String val_maison_watts  = "...";
String val_piscine_temp  = "...";
String val_pac_temp      = "";
String val_pv_watts      = "...";
String val_grid_watts    = "...";
String val_eau_litres    = "...";

float current_grid_watts_float = 0.0;

String last_val_heure = "";
String last_val_maison_watts = "";
String last_val_piscine_temp = "";
String last_val_pac_temp = "";
String last_val_pv_watts = "";
String last_val_grid_watts = "";
String last_val_eau_litres = "";

const unsigned long FORCE_REDRAW_INTERVAL = 10000;
unsigned long lastForceRedraw = 0;

struct PowerStats {
  float minPower = 99999;
  float maxPower = 0;
  float avgPower = 0;
  int sampleCount = 0;
  unsigned long lastUpdate = 0;
};
PowerStats powerStats;

void updatePowerStats(float watts) {
  if (watts < 0 || watts > 15000) return;
  powerStats.sampleCount++;
  if (watts < powerStats.minPower) powerStats.minPower = watts;
  if (watts > powerStats.maxPower) powerStats.maxPower = watts;
  powerStats.avgPower = ((powerStats.avgPower * (powerStats.sampleCount - 1)) + watts) / powerStats.sampleCount;
  powerStats.lastUpdate = millis();
  if (powerStats.sampleCount > 8640) {
    powerStats.sampleCount = 0;
    powerStats.minPower = 99999;
    powerStats.maxPower = 0;
    powerStats.avgPower = 0;
    writeLog(LOG_INFO, "Power statistics reset after 24h");
  }
}

#define PV_MAX_WATTS 2630.0f
float current_pv_watts_float = 0.0;
float last_current_pv_watts_float = -1;

// Polygone PV (zone de remplissage)
#define PV_TRAPEZE_P0_X 66
#define PV_TRAPEZE_P0_Y 69
#define PV_TRAPEZE_P1_X 141
#define PV_TRAPEZE_P1_Y 69
#define PV_TRAPEZE_P2_X 118
#define PV_TRAPEZE_P2_Y 100
#define PV_TRAPEZE_P3_X 40
#define PV_TRAPEZE_P3_Y 100

const int PV_GFX_X = min(PV_TRAPEZE_P0_X, PV_TRAPEZE_P3_X);
const int PV_GFX_Y = min(PV_TRAPEZE_P0_Y, PV_TRAPEZE_P1_Y);
const int PV_GFX_W = max(PV_TRAPEZE_P1_X, PV_TRAPEZE_P2_X) - PV_GFX_X;
const int PV_GFX_H = max(PV_TRAPEZE_P2_Y, PV_TRAPEZE_P3_Y) - PV_GFX_Y;

unsigned long lastFanFrameUpdate = 0;
int fanFrame = 0;
bool isPacRunning = false;
bool pacStateChanged = true;

bool isPumpRunning = false;
bool pumpStateChanged = true;
unsigned long lastWaveUpdate = 0;
const unsigned long WAVE_PERIOD_MS = 250;

std::vector<uint8_t> wave1_png;
std::vector<uint8_t> wave2_png;
std::vector<uint8_t> wave3_png;

bool isGridPositive = false;
bool gridArrowStateChanged = true;
unsigned long lastGridArrowUpdate = 0;
const unsigned long GRID_ARROW_PERIOD_MS = 180;
int gridArrowFrame = 0;

std::vector<uint8_t> grid_png[6];

struct ColorPoint { float watts; uint8_t r, g, b; };
const ColorPoint gradientPoints[] = {
  {     0,   0, 255,   0}, {   800,  50, 255,   0}, {  1600, 128, 255,   0},
  {  2400, 173, 255,  47}, {  3200, 255, 255,   0}, {  4000, 255, 215,   0},
  {  4800, 255, 165,   0}, {  5600, 255, 140,   0}, {  6400, 255, 100,   0},
  {  7200, 255,   0,   0}, {  8000, 220,  20,  60}, {  8800, 255,   0, 255},
  {  9600, 218, 112, 214}, { 10400, 138,  43, 226}, { 11200,  75,   0, 130},
  { 12000,  20,  20,  20}
};
const int numGradientPoints = sizeof(gradientPoints) / sizeof(ColorPoint);

uint8_t interpolate(uint8_t start, uint8_t end, float progress) { return start + (end - start) * progress; }
uint16_t getPowerGradientColor(float watts) {
  if (watts < 0) watts = 0;
  float calibrationFactor = 1.0;
  if (powerStats.maxPower > 0 && powerStats.sampleCount > 100) {
    calibrationFactor = 12000.0 / max(powerStats.maxPower, 1000.0f);
    calibrationFactor = constrain(calibrationFactor, 0.5, 2.0);
  }
  float adjustedWatts = watts * calibrationFactor;
  if (adjustedWatts >= 12000) {
    const ColorPoint& lastPoint = gradientPoints[numGradientPoints - 1];
    return M5.Display.color565(lastPoint.r, lastPoint.g, lastPoint.b);
  }
  for (int i = 0; i < numGradientPoints - 1; ++i) {
    const ColorPoint& s = gradientPoints[i];
    const ColorPoint& e = gradientPoints[i+1];
    if (adjustedWatts >= s.watts && adjustedWatts <= e.watts) {
      float range = e.watts - s.watts;
      float prog = (range == 0) ? 0 : (adjustedWatts - s.watts) / range;
      uint8_t r = interpolate(s.r, e.r, prog);
      uint8_t g = interpolate(s.g, e.g, prog);
      uint8_t b = interpolate(s.b, e.b, prog);
      return M5.Display.color565(r, g, b);
    }
  }
  return M5.Display.color565(20, 20, 20);
}

bool isValidTemperature(float temp, const String& source) {
  if (isnan(temp) || isinf(temp)) { writeLog(LOG_WARNING, source + " invalid temperature"); return false; }
  if (temp < -20 || temp > 60)     { writeLog(LOG_WARNING, source + " temperature out of range: " + String(temp)); return true; }
  return true;
}

String splitString(String data, char separator, int index) {
  int found = 0;
  int strIndex[] = {0, -1};
  int maxIndex = data.length() - 1;
  for (int i = 0; i <= maxIndex && found <= index; i++) {
    if (data.charAt(i) == separator || i == maxIndex) {
      found++;
      strIndex[0] = strIndex[1] + 1;
      strIndex[1] = (i == maxIndex) ? i + 1 : i;
    }
  }
  return found > index ? data.substring(strIndex[0], strIndex[1]) : "";
}

String formatTemperature(float temp) { return String(temp, 1); }

// === Format 3 caractères pour Shelly ===
String formatShelly3Chars(float watts) {
  if (watts < 0) watts = 0;
  if (watts < 1000) {
    int w = (int)roundf(watts);
    if (w > 999) w = 999;
    return String(w);
  }
  if (watts < 10000) {
    float kw = watts / 1000.0f;
    char buf[8];
    snprintf(buf, sizeof(buf), "%.1f", kw);
    buf[3] = '\0';
    return String(buf);
  }
  int tens = (int)(watts / 1000.0f + 0.5f);
  if (tens > 99) tens = 99;
  return String(tens) + ".";
}

void drawSpriteText(LGFX_Sprite& sp, int w, int h, const String& text,
                    uint8_t font, uint16_t color, uint16_t* bg_buffer,
                    textdatum_t datum, int x_offset = 0) {
  sp.setColorDepth(16);
  sp.pushImage(0, 0, w, h, bg_buffer);
  sp.setTextFont(font);
  sp.setTextColor(color);
  sp.setTextWrap(false);
  sp.setTextDatum(datum);
  int tx = (datum == textdatum_t::middle_left || datum == textdatum_t::top_left || datum == textdatum_t::baseline_left)
           ? x_offset : (w / 2);
  int ty = h / 2;
  sp.drawString(text, tx, ty);
}

void checkDataFreshness() {
  if (millis() - lastDataReceived > 30000) M5.Display.fillCircle(10, 10, 4, TFT_RED);
  else                                     M5.Display.fillCircle(10, 10, 4, TFT_GREEN);
}

void readAllBackgroundBuffers() {
  M5.Display.readRect(HEURE_DISP_X - (HEURE_DISP_W / 2), HEURE_DISP_Y - (HEURE_DISP_H / 2), HEURE_DISP_W, HEURE_DISP_H, bg_buffer_heure);
  M5.Display.readRect(MAISON_DISP_X - (MAISON_DISP_W / 2), MAISON_DISP_Y - (MAISON_DISP_H / 2), MAISON_DISP_W, MAISON_DISP_H, bg_buffer_maison);
  M5.Display.readRect(PV_DISP_X - (PV_DISP_W / 2), PV_DISP_Y - (PV_DISP_H / 2), PV_DISP_W, PV_DISP_H, bg_buffer_pv);
  M5.Display.readRect(GRID_DISP_X - (GRID_DISP_W / 2), GRID_DISP_Y - (GRID_DISP_H / 2), GRID_DISP_W, GRID_DISP_H, bg_buffer_grid);
  M5.Display.readRect(EAU_DISP_X - (EAU_DISP_W / 2), EAU_DISP_Y - (EAU_DISP_H / 2), EAU_DISP_W, EAU_DISP_H, bg_buffer_eau);
  M5.Display.readRect(PISCINE_DISP_X - (PISCINE_DISP_W / 2), PISCINE_DISP_Y - (PISCINE_DISP_H / 2), PISCINE_DISP_W, PISCINE_DISP_H, bg_buffer_piscine);
  M5.Display.readRect(PAC_DISP_X - (PAC_DISP_W / 2), PAC_DISP_Y - (PAC_DISP_H / 2), PAC_DISP_W, PAC_DISP_H, bg_buffer_pac);
  M5.Display.readRect(PV_GFX_X, PV_GFX_Y, PV_GFX_W, PV_GFX_H, bg_buffer_solar);
  M5.Display.readRect(PAC_FAN_X, PAC_FAN_Y, PAC_FAN_W, PAC_FAN_H, bg_buffer_fan);
  M5.Display.readRect(WAVE_X, WAVE_Y, WAVE_W, WAVE_H, bg_buffer_wave);
  M5.Display.readRect(GRID_ARROW_X, GRID_ARROW_Y, GRID_ARROW_W, GRID_ARROW_H, bg_buffer_grid_arrow);
  // Si un toast est à l'écran, on le cache pour éviter conflit lors d'un changement de fond
  if (toastVisible) { toastVisible = false; } // on laissera peut-être un nouveau toast s'afficher après
}

void updateTimeFromRTC() {
  struct tm timeinfo;
  if (getLocalTime(&timeinfo)) {
    char timeStr[6];
    sprintf(timeStr, "%02d:%02d", timeinfo.tm_hour, timeinfo.tm_min);
    val_heure = String(timeStr);
  }
}

void updateAllDisplays() {
  bool force = (millis() - lastForceRedraw > FORCE_REDRAW_INTERVAL);
  if (force) lastForceRedraw = millis();

  if (force || val_heure != last_val_heure) {
    drawSpriteText(spHeure, HEURE_DISP_W, HEURE_DISP_H, val_heure, HEURE_DISP_FONT, TFT_BLACK, bg_buffer_heure, textdatum_t::middle_center);
    spHeure.pushSprite(HEURE_DISP_X - HEURE_DISP_W / 2, HEURE_DISP_Y - HEURE_DISP_H / 2);
    last_val_heure = val_heure;
  }

  if (force || val_maison_watts != last_val_maison_watts) {
    float watts_value = val_maison_watts.toFloat() * (val_maison_watts.indexOf('.') > 0 ? 1000 : 1);
    updatePowerStats(watts_value);
    uint16_t maison_color = getPowerGradientColor(watts_value);
    drawSpriteText(spMaison, MAISON_DISP_W, MAISON_DISP_H, val_maison_watts, MAISON_DISP_FONT, maison_color, bg_buffer_maison, textdatum_t::middle_center);
    spMaison.pushSprite(MAISON_DISP_X - MAISON_DISP_W / 2, MAISON_DISP_Y - MAISON_DISP_H / 2);
    last_val_maison_watts = val_maison_watts;
  }

  if (force || val_pv_watts != last_val_pv_watts) {
    spPV.fillSprite(TFT_MAGENTA);
    spPV.setTextFont(PV_DISP_FONT);
    spPV.setTextColor(TFT_BLACK);
    spPV.setTextDatum(textdatum_t::middle_center);
    spPV.drawString(val_pv_watts, PV_DISP_W / 2, PV_DISP_H / 2);
    M5.Display.pushImage(PV_DISP_X - PV_DISP_W / 2, PV_DISP_Y - PV_DISP_H / 2, PV_DISP_W, PV_DISP_H, bg_buffer_pv);
    spPV.pushSprite(PV_DISP_X - PV_DISP_W / 2, PV_DISP_Y - PV_DISP_H / 2, TFT_MAGENTA);
    last_val_pv_watts = val_pv_watts;
  }

  if (force || val_grid_watts != last_val_grid_watts) {
    drawSpriteText(spGrid, GRID_DISP_W, GRID_DISP_H, val_grid_watts, GRID_DISP_FONT, TFT_BLACK, bg_buffer_grid, textdatum_t::middle_center);
    spGrid.pushSprite(GRID_DISP_X - GRID_DISP_W / 2, GRID_DISP_Y - GRID_DISP_H / 2);
    last_val_grid_watts = val_grid_watts;
  }

  if (force || val_eau_litres != last_val_eau_litres) {
    drawSpriteText(spEau, EAU_DISP_W, EAU_DISP_H, val_eau_litres, EAU_DISP_FONT, TFT_BLACK, bg_buffer_eau, textdatum_t::middle_center);
    spEau.pushSprite(EAU_DISP_X - EAU_DISP_W / 2, EAU_DISP_Y - EAU_DISP_H / 2);
    last_val_eau_litres = val_eau_litres;
  }

  if (force || val_piscine_temp != last_val_piscine_temp) {
    drawSpriteText(spPiscine, PISCINE_DISP_W, PISCINE_DISP_H, val_piscine_temp, PISCINE_DISP_FONT, TFT_BLACK, bg_buffer_piscine, textdatum_t::middle_left, 0);
    spPiscine.pushSprite(PISCINE_DISP_X - PISCINE_DISP_W / 2, PISCINE_DISP_Y - PISCINE_DISP_H / 2);
    last_val_piscine_temp = val_piscine_temp;
  }

  if (force || val_pac_temp != last_val_pac_temp) {
    drawSpriteText(spPAC, PAC_DISP_W, PAC_DISP_H, val_pac_temp, PAC_DISP_FONT, TFT_BLACK, bg_buffer_pac, textdatum_t::middle_center);
    spPAC.pushSprite(PAC_DISP_X - PAC_DISP_W / 2, PAC_DISP_Y - PAC_DISP_H / 2);
    last_val_pac_temp = val_pac_temp;
  }
}

void updateSolarFill() {
  if (fabs(current_pv_watts_float - last_current_pv_watts_float) < 10) return;
  last_current_pv_watts_float = current_pv_watts_float;
  float fillPercentage = current_pv_watts_float / PV_MAX_WATTS;
  if (fillPercentage < 0) fillPercentage = 0;
  if (fillPercentage > 1) fillPercentage = 1;
  spSolar.pushImage(0, 0, PV_GFX_W, PV_GFX_H, bg_buffer_solar);
  if (fillPercentage > 0.01) {
    int p0x = PV_TRAPEZE_P0_X - PV_GFX_X;
    int p0y = PV_TRAPEZE_P0_Y - PV_GFX_Y;
    int p1x = PV_TRAPEZE_P1_X - PV_GFX_X;
    int p2x = PV_TRAPEZE_P2_X - PV_GFX_X;
    int p3x = PV_TRAPEZE_P3_X - PV_GFX_X;
    int p3y = PV_TRAPEZE_P3_Y - PV_GFX_Y;
    int total_height = p3y - p0y;
    int fill_height = total_height * fillPercentage;
    int top_fill_y = p3y - fill_height;
    uint16_t color = TFT_GREEN;
    if (fillPercentage > 0.8) {
      int pulse = (millis() / 200) % 100;
      if (pulse > 50) pulse = 100 - pulse;
      color = M5.Display.color565(0, 255 - pulse, 0);
    }
    for (int y = top_fill_y; y <= p3y; ++y) {
      float progress_y = (total_height == 0) ? 0 : (float)(y - p0y) / total_height;
      if (progress_y < 0) progress_y = 0;
      if (progress_y > 1) progress_y = 1;
      int start_x = p0x + (p3x - p0x) * progress_y;
      int end_x   = p1x + (p2x - p1x) * progress_y;
      for (int x = start_x; x <= end_x; ++x) {
        if ((x + y) % 2 == 0) spSolar.drawPixel(x, y, color);
      }
    }
  }
  spSolar.pushSprite(PV_GFX_X, PV_GFX_Y);
}

void updatePacAnimation() {
  bool newPacState = (val_pac_temp.toFloat() >= 1.5);
  if (newPacState != isPacRunning) { isPacRunning = newPacState; pacStateChanged = true; }
  unsigned long now = millis();
  if (isPacRunning) {
    if (now - lastFanFrameUpdate > 200) {
      lastFanFrameUpdate = now;
      if (fanFrame == 0) { spFan.drawPng(fan_frame1_png, sizeof(fan_frame1_png)); fanFrame = 1; }
      else               { spFan.drawPng(fan_frame2_png, sizeof(fan_frame2_png)); fanFrame = 0; }
      spFan.pushSprite(PAC_FAN_X, PAC_FAN_Y);
    }
  } else if (pacStateChanged) {
    spFan.pushImage(0, 0, PAC_FAN_W, PAC_FAN_H, bg_buffer_fan);
    spFan.pushSprite(PAC_FAN_X, PAC_FAN_Y);
    pacStateChanged = false;
  }
}

void updatePoolWaves() {
  unsigned long now = millis();
  if (!isPumpRunning) {
    if (pumpStateChanged) {
      spWave.pushImage(0, 0, WAVE_W, WAVE_H, bg_buffer_wave);
      spWave.pushSprite(WAVE_X, WAVE_Y);
      pumpStateChanged = false;
    }
    return;
  }
  if (now - lastWaveUpdate < WAVE_PERIOD_MS) return;
  lastWaveUpdate = now;
  spWave.pushImage(0, 0, WAVE_W, WAVE_H, bg_buffer_wave);
  int r = random(0, 3);
  const std::vector<uint8_t>* src = (r == 0) ? &wave1_png : (r == 1) ? &wave2_png : &wave3_png;
  if (!src->empty()) spWave.drawPng(src->data(), src->size());
  spWave.pushSprite(WAVE_X, WAVE_Y);
}

void updateGridArrow() {
  unsigned long now = millis();
  if (!isGridPositive) {
    if (gridArrowStateChanged) {
      spGridArrow.pushImage(0, 0, GRID_ARROW_W, GRID_ARROW_H, bg_buffer_grid_arrow);
      spGridArrow.pushSprite(GRID_ARROW_X, GRID_ARROW_Y);
      gridArrowStateChanged = false;
    }
    return;
  }
  if (now - lastGridArrowUpdate < GRID_ARROW_PERIOD_MS) return;
  lastGridArrowUpdate = now;
  const std::vector<uint8_t>& frame = grid_png[gridArrowFrame];
  spGridArrow.pushImage(0, 0, GRID_ARROW_W, GRID_ARROW_H, bg_buffer_grid_arrow);
  if (!frame.empty()) spGridArrow.drawPng(frame.data(), frame.size());
  spGridArrow.pushSprite(GRID_ARROW_X, GRID_ARROW_Y);
  gridArrowFrame = (gridArrowFrame + 1) % 6;
}

// ==================== MQTT CALLBACK ====================
void mqttCallback(char* topic, byte* payload, unsigned int length) {
  String message; message.reserve(length);
  for (unsigned int i = 0; i < length; i++) message += (char)payload[i];
  message.trim();
  lastDataReceived = millis();

  if (strcmp(topic, TOPIC_PISCINE) == 0) {
    float temp = splitString(message, '/', 0).toFloat();
    if (isValidTemperature(temp, "piscine")) { val_piscine_temp = formatTemperature(temp); }
    String pac_temp_str = splitString(message, '/', 1);
    if (pac_temp_str != "") {
      float pac_temp_val = pac_temp_str.toFloat();
      if (isValidTemperature(pac_temp_val, "pac")) val_pac_temp = (pac_temp_val >= 1.5) ? formatTemperature(pac_temp_val) : "";
    } else { val_pac_temp = ""; }
  } else if (strcmp(topic, TOPIC_EAU) == 0) {
    val_eau_litres = splitString(message, '/', 0);
    val_eau_litres.trim();
    if (val_eau_litres != "" && val_eau_litres.toInt() > 0) val_eau_litres += "L";
    else                                                     val_eau_litres = "...";
  } else if (strcmp(topic, TOPIC_HEURE) == 0) {
    val_heure = message;
  } else if (strcmp(topic, TOPIC_POMPE_PISCINE) == 0) {
    bool newState = (message == "true" || message == "1" || message == "on" || message == "ON");
    if (newState != isPumpRunning) {
      isPumpRunning = newState;
      pumpStateChanged = true;
      writeLog(LOG_INFO, String("Pompe piscine: ") + (isPumpRunning ? "ON" : "OFF"));
    }
  }
}

// ==================== WIFI / MQTT ====================
void connectWifi() {
  if (WiFi.isConnected()) return;
  unsigned long now = millis();
  if (now - lastWifiReconnectAttempt < WIFI_RECONNECT_INTERVAL) return;
  lastWifiReconnectAttempt = now;
  wifiReconnectAttempts++;
  writeLog(LOG_INFO, "Connecting to WiFi: " + String(WIFI_SSID) + " (attempt " + String(wifiReconnectAttempts) + ")");
  WiFi.disconnect();
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  unsigned long startAttemptTime = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 15000) delay(500);
  if (WiFi.isConnected()) { writeLog(LOG_INFO, "WiFi connected. IP: " + WiFi.localIP().toString()); wifiReconnectAttempts = 0; }
  else                    { writeLog(LOG_ERROR, "WiFi connection failed"); }
}

void connectMqtt() {
  if (mqttClient.connected()) return;
  unsigned long now = millis();
  if (now - lastMqttReconnectAttempt < MQTT_RECONNECT_INTERVAL) return;
  lastMqttReconnectAttempt = now;
  mqttReconnectAttempts++;
  writeLog(LOG_INFO, "Connecting to MQTT (attempt " + String(mqttReconnectAttempts) + ")");
  int backoffDelay = min((int)60000, (int)(MQTT_RECONNECT_INTERVAL * (1 << min(mqttReconnectAttempts - 1, 4))));
  if (mqttClient.connect(MQTT_CLIENT_ID, MQTT_USER, MQTT_PASS)) {
    writeLog(LOG_INFO, "MQTT connected");
    mqttClient.subscribe(TOPIC_PISCINE);
    mqttClient.subscribe(TOPIC_EAU);
    mqttClient.subscribe(TOPIC_HEURE);
    mqttClient.subscribe(TOPIC_POMPE_PISCINE);
    lastDataReceived = millis();
    mqttReconnectAttempts = 0;
  } else {
    writeLog(LOG_ERROR, "MQTT connection failed, rc=" + String(mqttClient.state()) + ".");
    lastMqttReconnectAttempt += backoffDelay - MQTT_RECONNECT_INTERVAL;
  }
}

void cleanupBuffers() {
  if (bg_buffer_heure) { free(bg_buffer_heure); bg_buffer_heure = nullptr; }
  if (bg_buffer_maison) { free(bg_buffer_maison); bg_buffer_maison = nullptr; }
  if (bg_buffer_pv) { free(bg_buffer_pv); bg_buffer_pv = nullptr; }
  if (bg_buffer_grid) { free(bg_buffer_grid); bg_buffer_grid = nullptr; }
  if (bg_buffer_eau) { free(bg_buffer_eau); bg_buffer_eau = nullptr; }
  if (bg_buffer_piscine) { free(bg_buffer_piscine); bg_buffer_piscine = nullptr; }
  if (bg_buffer_pac) { free(bg_buffer_pac); bg_buffer_pac = nullptr; }
  if (bg_buffer_solar) { free(bg_buffer_solar); bg_buffer_solar = nullptr; }
  if (bg_buffer_fan) { free(bg_buffer_fan); bg_buffer_fan = nullptr; }
  if (bg_buffer_wave) { free(bg_buffer_wave); bg_buffer_wave = nullptr; }
  if (bg_buffer_grid_arrow) { free(bg_buffer_grid_arrow); bg_buffer_grid_arrow = nullptr; }
  if (bg_buffer_toast) { free(bg_buffer_toast); bg_buffer_toast = nullptr; }
}

void cleanupPNGBuffers() {
  wave1_png.clear();
  wave1_png.shrink_to_fit();
  wave2_png.clear();
  wave2_png.shrink_to_fit();
  wave3_png.clear();
  wave3_png.shrink_to_fit();
  
  for (int i = 0; i < 6; ++i) {
    grid_png[i].clear();
    grid_png[i].shrink_to_fit();
  }
}

// ==================== PARTAGE DONNÉES SHELLY ====================
volatile float g_rawMaisonW = NAN;
volatile float g_rawPVW     = NAN;
volatile bool  g_hasNewShelly = false;
portMUX_TYPE g_shellyMux = portMUX_INITIALIZER_UNLOCKED;

// ==================== DEBUG MODE ====================
void toggleDebugMode() {
  debugMode = !debugMode;
  writeLog(LOG_INFO, "Debug mode " + String(debugMode ? "enabled" : "disabled"));
  if (debugMode) {
    debugScrollOffset = 0;
    debugMessages = "";
    M5.Display.fillScreen(TFT_BLACK);
  } else {
    // Retour à l'écran normal
    backgroundImageChanged = true;
    applyModeChangeNow();
  }
}

void updateDebugDisplay() {
  if (!debugMode) return;
  
  unsigned long now = millis();
  if (now - lastDebugScroll > DEBUG_SCROLL_DELAY) {
    lastDebugScroll = now;
    debugScrollOffset++;
    
    M5.Display.fillScreen(TFT_BLACK);
    M5.Display.setTextColor(TFT_WHITE);
    M5.Display.setTextFont(2);
    M5.Display.setTextDatum(textdatum_t::top_left);
    
    int y = 10 - debugScrollOffset;
    int lineHeight = 15;
    
    // Afficher les messages de debug
    int startPos = 0;
    int endPos = 0;
    int lineCount = 0;
    
    while (endPos != -1 && lineCount < 20) {
      endPos = debugMessages.indexOf('\n', startPos);
      String line;
      if (endPos == -1) {
        line = debugMessages.substring(startPos);
      } else {
        line = debugMessages.substring(startPos, endPos);
        startPos = endPos + 1;
      }
      
      if (y + lineCount * lineHeight < 240 && y + lineCount * lineHeight > -lineHeight) {
        M5.Display.drawString(line, 5, y + lineCount * lineHeight);
      }
      
      lineCount++;
      if (endPos == -1) break;
    }
    
    // Si on a défilé trop loin, réinitialiser
    if (y + lineCount * lineHeight < 0) {
      debugScrollOffset = 0;
    }
  }
}

void debugLogSystemStatus() {
  if (debugMode) {
    writeLog(LOG_DEBUG, "Heap: " + String(ESP.getFreeHeap()) + 
             "B, WiFi: " + String(WiFi.RSSI()) + "dBm" +
             ", Mode: " + String(currentDisplayMode) +
             ", Night: " + String(isNightMode));
  }
}

// ============================ SETUP & TASKS =========================
TaskHandle_t g_shellyTaskHandle = nullptr;

void shellyTask(void* arg) {
  uint32_t lastPoll = 0;
  for (;;) {
    if (!WiFi.isConnected()) { vTaskDelay(pdMS_TO_TICKS(500)); continue; }
    uint32_t now = millis();
    if (now - lastPoll < SHELLY_POLL_MS) { vTaskDelay(pdMS_TO_TICKS(10)); continue; }
    lastPoll = now;

    HTTPClient http;
    String url = String("http://") + SHELLY_HOST + "/rpc/Shelly.GetStatus";
    if (!http.begin(url)) { vTaskDelay(pdMS_TO_TICKS(200)); continue; }
    http.setTimeout(700);

    int code = http.GET();
    if (code == 200) {
      StaticJsonDocument<128> filter;
      filter["em1:0"]["act_power"] = true; // conso maison
      filter["em1:1"]["act_power"] = true; // prod PV

      DynamicJsonDocument doc(256);
      DeserializationError err = deserializeJson(doc, http.getStream(), DeserializationOption::Filter(filter));
      if (!err) {
        float m = doc["em1:0"]["act_power"] | NAN; // Maison
        float p = doc["em1:1"]["act_power"] | NAN; // PV
        portENTER_CRITICAL(&g_shellyMux);
        g_rawMaisonW = m;
        g_rawPVW     = p;
        g_hasNewShelly = true;
        portEXIT_CRITICAL(&g_shellyMux);
      }
    }
    http.end();
    vTaskDelay(pdMS_TO_TICKS(10));
  }
}

// ============================ SETUP & LOOP ===========================
void setup() {
  auto cfg = M5.config();
  M5.begin(cfg);
  Serial.begin(115200);
  bootTime = millis();
  randomSeed(esp_random());
  M5.Display.setBrightness(200);
  currentBrightness = 200;
  M5.Display.setTextDatum(textdatum_t::middle_center);

  if (!SD.begin(4)) {
    M5.Display.fillScreen(TFT_RED);
    M5.Display.drawString("Erreur Carte SD", M5.Display.width()/2, M5.Display.height()/2);
    while (1) delay(1000);
  }

  writeLog(LOG_INFO, "=== SYSTEM BOOT ===");
  writeLog(LOG_INFO, "M5Stack Core2 Dashboard v15.4 (Calcul astronomique corrigé)");
  writeLog(LOG_INFO, "Location: " + String(LATITUDE, 6) + ", " + String(LONGITUDE, 6));

  connectWifi();
  configTime(GMT_OFFSET_SEC, DAYLIGHT_OFFSET_SEC, NTP_SERVER);
  delay(2000);

  calculateSolarTimes();
  lastSolarCalculation = millis();

  bool initialNightMode = shouldBeNightMode();
  if (!drawBackgroundFromSD(initialNightMode)) {
    writeLog(LOG_ERROR, "Background image not found, trying fallback");
    if (!drawBackgroundFromSD(false)) {
      M5.Display.fillScreen(TFT_BLACK);
      M5.Display.drawString("Image de fond non trouvée", M5.Display.width()/2, M5.Display.height()/2);
      while(1) delay(1000);
    }
  }
  isNightMode = initialNightMode;
  writeLog(LOG_INFO, "Initial mode: " + String(isNightMode ? "NIGHT" : "DAY"));

  bool ok1 = readFileToBuffer("/wave1.png", wave1_png);
  bool ok2 = readFileToBuffer("/wave2.png", wave2_png);
  bool ok3 = readFileToBuffer("/wave3.png", wave3_png);
  if (!(ok1 && ok2 && ok3)) writeLog(LOG_ERROR, "PNG vagues manquants (/wave1.png, /wave2.png, /wave3.png)");

  bool okGrid = true;
  for (int i = 0; i < 6; ++i) {
    String p = "/grid" + String(i+1) + ".png";
    if (!readFileToBuffer(p, grid_png[i])) okGrid = false;
  }
  if (!okGrid) writeLog(LOG_ERROR, "PNG flèche grid manquants (/grid1..6.png)");

  size_t total_buffer_size =
      (HEURE_DISP_W * HEURE_DISP_H) +
      (MAISON_DISP_W * MAISON_DISP_H) +
      (PV_DISP_W * PV_DISP_H) +
      (GRID_DISP_W * GRID_DISP_H) +
      (EAU_DISP_W * EAU_DISP_H) +
      (PISCINE_DISP_W * PISCINE_DISP_H) +
      (PAC_DISP_W * PAC_DISP_H) +
      (PV_GFX_W * PV_GFX_H) +
      (PAC_FAN_W * PAC_FAN_H) +
      (WAVE_W * WAVE_H) +
      (GRID_ARROW_W * GRID_ARROW_H);
  total_buffer_size *= sizeof(uint16_t);
  writeLog(LOG_INFO, "Total buffer memory needed: " + String(total_buffer_size) + " bytes");

  bg_buffer_heure   = (uint16_t*)malloc(HEURE_DISP_W * HEURE_DISP_H * sizeof(uint16_t));
  bg_buffer_maison  = (uint16_t*)malloc(MAISON_DISP_W * MAISON_DISP_H * sizeof(uint16_t));
  bg_buffer_pv      = (uint16_t*)malloc(PV_DISP_W * PV_DISP_H * sizeof(uint16_t));
  bg_buffer_grid    = (uint16_t*)malloc(GRID_DISP_W * GRID_DISP_H * sizeof(uint16_t));
  bg_buffer_eau     = (uint16_t*)malloc(EAU_DISP_W * EAU_DISP_H * sizeof(uint16_t));
  bg_buffer_piscine = (uint16_t*)malloc(PISCINE_DISP_W * PISCINE_DISP_H * sizeof(uint16_t));
  bg_buffer_pac     = (uint16_t*)malloc(PAC_DISP_W * PAC_DISP_H * sizeof(uint16_t));
  bg_buffer_solar   = (uint16_t*)malloc(PV_GFX_W * PV_GFX_H * sizeof(uint16_t));
  bg_buffer_fan     = (uint16_t*)malloc(PAC_FAN_W * PAC_FAN_H * sizeof(uint16_t));
  bg_buffer_wave    = (uint16_t*)malloc(WAVE_W * WAVE_H * sizeof(uint16_t));
  bg_buffer_grid_arrow = (uint16_t*)malloc(GRID_ARROW_W * GRID_ARROW_H * sizeof(uint16_t));
  // buffer toast alloué à la demande

  if (!bg_buffer_heure || !bg_buffer_maison || !bg_buffer_pv || !bg_buffer_grid ||
      !bg_buffer_eau || !bg_buffer_piscine || !bg_buffer_pac || !bg_buffer_solar ||
      !bg_buffer_fan || !bg_buffer_wave || !bg_buffer_grid_arrow) {
    writeLog(LOG_ERROR, "Memory allocation failed!");
    M5.Display.fillScreen(TFT_RED);
    M5.Display.drawString("Erreur mémoire !", M5.Display.width()/2, M5.Display.height()/2);
    while(1) delay(1000);
  }
  writeLog(LOG_INFO, "Memory allocation successful");

  readAllBackgroundBuffers();

  spHeure.createSprite(HEURE_DISP_W, HEURE_DISP_H);
  spMaison.createSprite(MAISON_DISP_W, MAISON_DISP_H);
  spPV.createSprite(PV_DISP_W, PV_DISP_H);
  spGrid.createSprite(GRID_DISP_W, GRID_DISP_H);
  spEau.createSprite(EAU_DISP_W, EAU_DISP_H);
  spPiscine.createSprite(PISCINE_DISP_W, PISCINE_DISP_H);
  spPAC.createSprite(PAC_DISP_W, PAC_DISP_H);
  spSolar.createSprite(PV_GFX_W, PV_GFX_H);
  spSolar.setColorDepth(16);
  spFan.createSprite(PAC_FAN_W, PAC_FAN_H);
  spFan.setColorDepth(16);
  spWave.createSprite(WAVE_W, WAVE_H);
  spWave.setColorDepth(16);
  spGridArrow.createSprite(GRID_ARROW_W, GRID_ARROW_H);
  spGridArrow.setColorDepth(16);

  spHeure.setTextPadding(HEURE_DISP_W);
  spMaison.setTextPadding(MAISON_DISP_W);
  spPV.setTextPadding(PV_DISP_W);
  spGrid.setTextPadding(GRID_DISP_W);
  spEau.setTextPadding(EAU_DISP_W);
  spPiscine.setTextPadding(PISCINE_DISP_W);
  spPAC.setTextPadding(PAC_DISP_W);

  mqttClient.setServer(MQTT_BROKER, 1883);
  mqttClient.setKeepAlive(MQTT_KEEPALIVE_SECONDS);
  mqttClient.setCallback(mqttCallback);

  xTaskCreatePinnedToCore(shellyTask, "ShellyPoll", 8192, nullptr, 1, &g_shellyTaskHandle, 0);

  lastDataReceived = millis();
  updateBrightness();

  writeLog(LOG_INFO, "Setup completed successfully");
  writeLog(LOG_INFO, "Free heap: " + String(ESP.getFreeHeap()) + " bytes");

  if (solarTimes.isValid) {
    writeLog(LOG_INFO, "Solar times: Sunrise " + String(solarTimes.sunriseHour) + ":" +
             String(solarTimes.sunriseMinute) + ", Sunset " + String(solarTimes.sunsetHour) + ":" +
             String(solarTimes.sunsetMinute));
  }
}

// ==================== TOUCH HANDLER ====================
void handleTouch() {
  M5.update();
  bool currentlyTouched = M5.Touch.getCount() > 0;
  unsigned long now = millis();

  if (currentlyTouched && !touchState.isTouched) {
    touchState.isTouched = true;
    auto touch = M5.Touch.getDetail(0);
    
    // Vérifier le double tap en haut à gauche (debug mode)
    if (touch.x >= DEBUG_TOUCH_X && touch.x <= DEBUG_TOUCH_X + DEBUG_TOUCH_W &&
        touch.y >= DEBUG_TOUCH_Y && touch.y <= DEBUG_TOUCH_Y + DEBUG_TOUCH_H) {
      if (touchState.tapCount == 0 || (now - touchState.firstTapTime > DOUBLE_TAP_TIMEOUT)) {
        touchState.firstTapTime = now; touchState.tapCount = 1;
        writeLog(LOG_DEBUG, "First tap detected in debug zone");
      } else if (touchState.tapCount == 1 && (now - touchState.firstTapTime <= DOUBLE_TAP_TIMEOUT)) {
        touchState.doubleTapDetected = true; touchState.tapCount = 0;
        writeLog(LOG_INFO, "Double tap detected in debug zone!");
      }
    }
    // Vérifier le double tap en haut à droite (changement de mode)
    else if (touch.x >= HOUR_TOUCH_X && touch.x <= HOUR_TOUCH_X + HOUR_TOUCH_W &&
        touch.y >= HOUR_TOUCH_Y && touch.y <= HOUR_TOUCH_Y + HOUR_TOUCH_H) {
      if (touchState.tapCount == 0 || (now - touchState.firstTapTime > DOUBLE_TAP_TIMEOUT)) {
        touchState.firstTapTime = now; touchState.tapCount = 1;
        writeLog(LOG_DEBUG, "First tap detected in hour zone");
      } else if (touchState.tapCount == 1 && (now - touchState.firstTapTime <= DOUBLE_TAP_TIMEOUT)) {
        touchState.doubleTapDetected = true; touchState.tapCount = 0;
        writeLog(LOG_INFO, "Double tap detected in hour zone!");
      }
    }
    touchState.lastTapTime = now;
  } else if (!currentlyTouched && touchState.isTouched) {
    touchState.isTouched = false;
  }

  if (touchState.tapCount > 0 && (now - touchState.firstTapTime > DOUBLE_TAP_TIMEOUT)) touchState.tapCount = 0;

  if (touchState.doubleTapDetected && (now - lastModeSwitch > MODE_SWITCH_COOLDOWN)) {
    touchState.doubleTapDetected = false;
    lastModeSwitch = now;

    // Déterminer quelle zone a été tapée
    auto touch = M5.Touch.getDetail(0);
    
    if (touch.x >= DEBUG_TOUCH_X && touch.x <= DEBUG_TOUCH_X + DEBUG_TOUCH_W &&
        touch.y >= DEBUG_TOUCH_Y && touch.y <= DEBUG_TOUCH_Y + DEBUG_TOUCH_H) {
      // Zone debug - basculer le mode debug
      toggleDebugMode();
    } else {
      // Zone heure - cycle des modes d'affichage
      switch (currentDisplayMode) {
        case MODE_AUTO:
          currentDisplayMode = MODE_FORCE_NIGHT;
          writeLog(LOG_INFO, "Mode switched to FORCE_NIGHT");
          break;
        case MODE_FORCE_NIGHT:
          currentDisplayMode = MODE_FORCE_DAY;
          writeLog(LOG_INFO, "Mode switched to FORCE_DAY");
          break;
        case MODE_FORCE_DAY:
          currentDisplayMode = MODE_AUTO;
          writeLog(LOG_INFO, "Mode switched to AUTO");
          break;
      }

      backgroundImageChanged = true;
      applyModeChangeNow(); // application immédiate + toast
    }
  }
}

// ==================== HEALTH CHECK ====================
void checkSystemHealth() {
  unsigned long now = millis();
  if (now - lastDataReceived > DATA_TIMEOUT) { writeLog(LOG_ERROR, "Data timeout exceeded 5 minutes - rebooting"); delay(1000); ESP.restart(); }
  if (mqttReconnectAttempts > MAX_RECONNECT_ATTEMPTS) { writeLog(LOG_ERROR, "Too many MQTT reconnect attempts - rebooting"); delay(1000); ESP.restart(); }
  if (wifiReconnectAttempts > MAX_RECONNECT_ATTEMPTS) { writeLog(LOG_ERROR, "Too many WiFi reconnect attempts - rebooting"); delay(1000); ESP.restart(); }
  if (WiFi.isConnected()) wifiReconnectAttempts = 0;
  if (mqttClient.connected()) mqttReconnectAttempts = 0;
}

// ==================== LOOP ====================
void loop() {
  M5.update();
  unsigned long now = millis();

  checkSystemHealth();
  handleTouch();
  maybeUpdateToast(); // gérer disparition du toast

  if (debugMode) {
    updateDebugDisplay();
    debugLogSystemStatus();
  } else {
    if (now - lastLogCleanup > LOG_CLEANUP_INTERVAL) { lastLogCleanup = now; cleanupLogs(); }

    struct tm timeinfo;
    if (getLocalTime(&timeinfo) &&
        ((timeinfo.tm_hour == 0 && timeinfo.tm_min < 5 && (now - lastSolarCalculation > 3600000)) ||
         (!solarTimes.isValid && (now - lastSolarCalculation > 10000)))) {
      calculateSolarTimes();
      lastSolarCalculation = now;
    }

    if (now - lastBrightnessCheck > BRIGHTNESS_CHECK_INTERVAL) {
      lastBrightnessCheck = now;
      updateBrightness();

      bool shouldBeNight = shouldBeNightMode();
      bool inTransition = false;
      if (currentDisplayMode == MODE_AUTO && solarTimes.isValid) {
        int currentMinutes = timeinfo.tm_hour * 60 + timeinfo.tm_min;
        int sunriseMinutes = solarTimes.sunriseHour * 60 + solarTimes.sunriseMinute;
        int sunsetMinutes  = solarTimes.sunsetHour  * 60 + solarTimes.sunsetMinute;
        bool sunriseTransition = (currentMinutes == sunriseMinutes + 15);
        bool sunsetTransition  = (currentMinutes == sunsetMinutes + 15);
        inTransition = sunriseTransition || sunsetTransition;
      }
      if (shouldBeNight != isNightMode || inTransition || backgroundImageChanged) {
        isNightMode = shouldBeNight;
        backgroundImageChanged = false;
        writeLog(LOG_INFO, "Switching to " + String(isNightMode ? "night" : "day") + " mode");
        if (!drawBackgroundFromSD(isNightMode)) { writeLog(LOG_ERROR, "Failed to load background, using fallback"); drawBackgroundFromSD(false); }
        readAllBackgroundBuffers();
        if (toastVisible) { // si un toast était là, on le redessine proprement
          showModeToast(toastText.c_str());
        }
      }
    }

    if (!WiFi.isConnected()) {
      connectWifi();
    } else if (!mqttClient.connected()) {
      connectMqtt();
    }
    if (mqttClient.connected()) mqttClient.loop();

    // Données Shelly
    static float s_lastMaison = 0, s_lastPV = 0;
    bool applyShelly = false;
    float maisonW = NAN, pvW = NAN;

    if (g_hasNewShelly) {
      portENTER_CRITICAL(&g_shellyMux);
      maisonW = g_rawMaisonW;
      pvW     = g_rawPVW;
      g_hasNewShelly = false;
      portEXIT_CRITICAL(&g_shellyMux);
      applyShelly = true;
    }

    if (applyShelly && !isnan(maisonW) && !isnan(pvW)) {
      if (pvW < 10) pvW = 0;
      current_pv_watts_float = pvW;
      val_pv_watts = formatShelly3Chars(pvW);

      if (maisonW >= 0) {
        val_maison_watts = formatShelly3Chars(maisonW);
        current_grid_watts_float = 0;
        val_grid_watts = "0";
      } else {
        float inj = fabs(maisonW);
        val_maison_watts = "0";
        current_grid_watts_float = inj;
        val_grid_watts = formatShelly3Chars(inj);
      }

      bool newGridPositive = (current_grid_watts_float > 0.0f);
      if (newGridPositive != isGridPositive) {
        isGridPositive = newGridPositive;
        gridArrowStateChanged = true;
        writeLog(LOG_DEBUG, String("Grid surplus: ") + (isGridPositive ? "POSITIVE" : "ZERO/NEGATIVE"));
      }

      lastDataReceived = now;
      s_lastMaison = maisonW; s_lastPV = pvW;
    }

    // Animations
    updatePacAnimation();
    updatePoolWaves();
    updateGridArrow();
    checkDataFreshness();

    // Cadence d'affichage
    if (now - lastDisplayUpdate > 1000) {
      lastDisplayUpdate = now;
      updateTimeFromRTC();
      updateSolarFill();
      updateAllDisplays();
    }
  }

  delay(10);
}